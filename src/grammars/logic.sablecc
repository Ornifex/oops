/**
  * This program (working title: MAS Prover) is an automated tableaux prover
  * for epistemic logic (S5n).
  * Copyright (C) 2007  Elske van der Vaart and Gert van Valkenhoef

  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation.

  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
Package nl.rug.ai.mas.prover.parser;

Helpers
	lowercase = ['a' .. 'z'];
	uppercase = ['A' .. 'Z'];
	digit = ['0' .. '9'];
	space = ' ';
	tab = 9;
	lf = 10;
	cr = 13;
	newline = cr lf | lf | cr;
	any = [0x0 .. 0xffff];

Tokens
	prop = lowercase (lowercase | uppercase | digit | '_')*;
	var = uppercase (lowercase | uppercase | digit | '_')*;
	id = digit*;
	and = '&';
	or = '|';
	impl = '>';
	equiv = '=';
	neg = '~';
	box_multi = '#_';
	dia_multi = '%_';
	box_single = '#';
	dia_single = '%';
	assign = ':';
	term = ';';
	lbrace = '{';
	rbrace = '}';
	comma = ',';
	lparen = '(';
	rparen = ')';
	subscr = '_';
	ignore = space | tab | newline;
	comment = '/''/' [any - [cr + lf]]* newline;

Ignored Tokens
	ignore, comment;

Productions
/*
	command {->command} =
		{formula} formula term
			{ -> New command.formula(formula.formula) } | 
		{list} [list]:enclosed_formula_list term 
			{ -> New command.formula_list(list.formula_list) } |
		{assign} assignment term
			{ -> New command.assignment(assignment.assignment) };

	assignment {->assignment} =
		var assign [list]:enclosed_formula_list
			{ -> New assignment(var, list.formula_list) };
*/

	formula {-> formula} =
		{imp} [l]:disjunction impl [r]:formula
			{ -> New formula.implication(l.formula, r.formula) } |
		{eqv} [l]:disjunction equiv [r]:formula
			{ -> New formula.bi_implication(l.formula, r.formula) } |
		{base} disjunction
			{ -> disjunction.formula };

	simple_formula {->formula} =
		{proposition} prop 
			{ -> New formula.proposition(prop) } |
		{variable} var
			{ -> New formula.variable(var) } |
		{negation} neg simple_formula 
			{ -> New formula.negation(simple_formula.formula) } |
		{box} P.box simple_formula 
			{ -> New formula.box(box.box, simple_formula.formula) } |
		{dia} P.dia simple_formula 
			{ -> New formula.diamond(dia.diamond, simple_formula.formula) } |
		{nest} lparen formula rparen
			{ -> formula.formula };

	disjunction {->formula} = 
		{base} conjunction
			{ -> conjunction.formula } |
		{disj} [l]:disjunction or [r]:conjunction
			{ -> New formula.disjunction(l.formula, r.formula) };

	conjunction {->formula} = 
		{base} [r]:simple_formula 
			{ -> r.formula } |
		{conj} [l]:conjunction and [r]:simple_formula
			{ -> New formula.conjunction(l.formula, r.formula) };

	box {-> box} =
		{single} box_single
			{ -> New box.empty() } |
		{multi} box_multi P.id
			{ -> New box.id(id.id) } ;
	dia {-> diamond} = 
		{single} dia_single 
			{ -> New diamond.empty() } |
		{multi} dia_multi P.id
			{ -> New diamond.id(id.id) } ;

	id {->P.id} =
		T.id { -> New id(id) };
/*
	enclosed_formula_list {-> formula_list} =
		lbrace formula_list rbrace
			{ -> formula_list.formula_list } ;

	formula_list {->formula_list} =
		{formula_list_nonempty} [list]:formula_list_nonempty 
			{ -> New formula_list([list.formula]) } |
		{fomula_list_empty} [list]:formula_list_empty
			{ -> New formula_list([list.formula]) } ;

	formula_list_empty {->formula*} = 
		{empty} { -> [] };

	formula_list_nonempty {-> formula*} = 
		{base} formula
			{ -> [formula.formula] } |
		{ind} [list]:formula_list_nonempty comma formula
			{ -> [list.formula, formula.formula] };
*/
Abstract Syntax Tree
/*
	command = {formula} formula |
		{formula_list} formula_list |
		{assignment} assignment;

	assignment = [l]:var [r]:formula_list;

	formula_list = formula*;
*/

	formula = 
		{proposition} prop |
		{variable} var |
		{negation} formula |
		{box} box formula |
		{diamond} diamond formula |
		{conjunction} [l]:formula [r]:formula |
		{disjunction} [l]:formula [r]:formula |
		{implication} [l]:formula [r]:formula |
		{bi_implication} [l]:formula [r]:formula;

	proposition = proposition;
	variable = variable;
	id = T.id;

	box = {empty} | {id} P.id;
	diamond = {empty} | {id} P.id;

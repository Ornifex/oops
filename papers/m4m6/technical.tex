\section{Technical description}

In this section, we will first give a brief description of the tableaux method
used in \oops\ and summarize the formal properties (soundness, completeness,
complexity) of the system. This is followed by a description of how the
tableaux system is implemented in Java. Finally, we describe the input language
for modal formulas that is provided by \oops.

\subsection{\oops\ tableaux}

The \oops\ tableaux system for $S5_n$ is a Java \citep{gosling2005}
implementation of the proof system {\bf ELtap} \citep{deboer2006}.  {\bf
ELtap}, in turn, draws on \citet{fitting1999} and \citet{beckert1997}.
\citet{halpern1992} provide a good review of tableaux methods for modal logics.
Here, we summarize how tableaux are formalized in \oops. For a complete
description, see \citet{valkenhoef2008}.

When we construct a tableau, we do so with the aim of creating a Kripke model
in which a formula $\varphi$ is satisfied. This is done by assuming $\varphi$
is true and then systematically working out the implications of this
assumption. Specifically, \oops\ generates a collection of branches that each
represent alternative ways of working out these implications. A {\em branch}
$B$ consists of a number of nodes. A {\em node} $\gamma$ is a combination of a
{\em formula} $\psi$ and a {\em label} $\sigma$. A label is systematically
chosen name for a world in the Kripke model that is being constructed. Branches
are created and expanded by the application of {\em rules} to existing nodes on
a branch. 

\input{rules.tex}

A {\em rule} $R$ consists of
\begin{itemize}
\item A precondition $\mathrm{pre}(R)$, written above a horizontal bar, which
is a node containing variables;
\item A postcondition $\mathrm{post}(R)$, written below the horizontal bar,
which is a list of nodes containing variables. There are two types of
postconditions:
\begin{itemize}
\item Linear: add nodes to the current branch, written top-to-bottom;
\item Branching: create a number of new branches, written left-to-right, separated by a vertical bar.
\end{itemize}
\item Zero or more constraints, which restrict the values variables may take.
\end{itemize}
The rules employed by \oops\ are given in Table~\ref{tab:rules}. A rule $R$ is
applicable to a branch $B$, if there is a node $\gamma \in B$ that matches
$\mathrm{pre}(R)$, such that no constraints are violated and $R$ has not
previously been applied to $\gamma$.

A branch $B$ is {\em closed} if there is a label $\sigma$ and a formula
$\psi$, such that both $(\sigma, \psi) \in B$ and $(\sigma, \neg \psi)
\in B$. A branch $B$ is {\em open} if it is not closed and no more rules can be
applied to it. Thus, an open branch corresponds to a successful attempt to
satisfy $\varphi$, whereas a closed branch corresponds to a failed attempt to
satisfy $\varphi$. 
Specifically, for an open branch $B$, the labels determine the set of worlds
and the accessibility relations in the corresponding Kripke model. For each
label, the set of formulas given for that label determines the valuation in the
corresponding world in the Kripke model.
A tableau for $\varphi$ is closed if all branches are
closed, otherwise it is open. The appropriateness of a tableau system is
determined by the following properties:
\begin{description}
\item[Soundness] If the tableau for $\varphi$ is open, $\varphi$ is satisfiable.
\item[Completeness] If the tableau for $\varphi$ is closed, $\varphi$ is not
satisfiable.
\end{description}


The proof system used by \oops\ has been shown to be both sound and complete
\citep{valkenhoef2008}.  Furthermore, in the same work, the implementation was
shown to correspond to the formal description of the proof method.
Unfortunately, this work also shows that the algorithm used by \oops\ is in
{\sc EXPTIME}, whereas satisfiability for $S5_n$ is known to be {\sc PSPACE}
complete \citep{halpern1992}.
However, we believe that for educational purposes the functionality  offered
by \oops\ (see Section~\ref{sec:features}) easily makes up for this
shortcoming. Moreover, the implementation of these features does not depend on
the specific proof rules used. Thus, as future work, the current algorithm may
be replaced by one that is in {\sc PSPACE}.

\subsection{Implementation}

Above, we have defined what constitutes a tableau and how a tableau can be used
to determine the satisfiability of a formula. In Table~\ref{tab:rules}, the
rules that are used to generate the tableau are given. Now, in order to
generate tableaux, we also need an algorithm that correctly and exhaustively
applies the rules.

In order to ensure the exhaustive, but non-redundant application of rules,
\oops\ employs two data structures: the {\em match queue} and the {\em
necessities list}.
Whenever a node is added to the branch, we attempt to match every possible
rule to that node. The resulting matches are placed on the match queue. Now,
the Basic Necessity rules (Table~\ref{tab:rules}) pose a specific problem:
the postcondition may apply to labels that have not been generated yet. To
address this, partially matched postconditions of these rules are stored in
the necessities list. Whenever a new label is generated, any matches from this
list to the new label are added to the match queue.
These data structures are specific to a branch, i.e., when
a new branch is created, it receives a copy of the current match queue and
necessities list.

In fact, the match queue is a priority queue and rules can be given a numeric
priority value, that specifies the order in which matches are applied to the
tableau. In this way, we may define a strategy to close branches as soon as
possible. For example, it is preferable to execute any non-branching purely
propositional rules before attempting to execute any other rules.

The rules are implemented in such a way that they are easily replaceable by a
different ruleset. Moreover, the tableau generator has been instrumented with
a number of hooks that allow the generation process to be monitored. This
allows the decoupled implementation of such features as tableau visualization
and counter-model construction (see Section~\ref{sec:features}).

\subsection{Input language}

\oops\ employs an input language for formulas implemented using the SableCC
\citep{gagnon1998} compiler generator for Java. Propositions are input as
strings of characters and digits, starting with a lower case character.  Agent
identities are represented by natural numbers. \oops\ uses the widely
understood infix notation for logical formulas, where the different
connectives are input as shown in Table~\ref{tab:input}.

\begin{table}
\label{tab:input}
\begin{tabular}{cc}
Logical Operator & OOPS Symbol \\
$\neg$ & \tt{$\sim$} \\ 
$\wedge$ & \tt{\&} \\
$\vee$ & \tt{|} \\
$\rightarrow$ & \tt{>} \\
$\leftrightarrow$ & \tt{=} \\
$\Box_i$ & \tt{\#\_i}  \\
$\Diamond_i$ & \tt{\%\_i}  \\
\end{tabular}
\caption{\oops\ Connectives}
\end{table}

In addition to this, the language also allows the input of variables as
placeholders for either (sub-)formulas or agent identities. This is useful in
the definition of rules and allows one to create template formulas that can
be instantiated in different ways, by substitution.

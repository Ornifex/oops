\section{Technical description}

In this section, we will first give a brief description of the tableaux method
used in \oops\ and summarize the formal properties (soundness, completeness,
complexity) of the system. This is followed by a description of how the
tableaux system is implemented in Java. Finally, we describe the input language
for modal formulas that is provided by \oops.

\subsection{\oops\ tableaux}

The \oops\ tableaux system for $S5_n$ is a Java \citep{gosling2005}
implementation of the proof system {\bf ELtap} \citep{deboer2006}.  {\bf
ELtap}, in turn, draws on \citet{fitting1999} and \citet{beckert1997}.
\citet{halpern1992} provide a good review of tableaux methods for modal logics.
Here, we summarize how tableaux are formalized in \oops. For a complete
description, see \citet{valkenhoef2008}.

When we construct a tableau, we do so with the aim of creating a Kripke model
in which a formula $\varphi$ is satisfied. This is done by assuming $\varphi$
is true and then systematically working out the implications of this
assumption. Specifically, \oops\ generates a collection of branches that each
represent alternative ways of working out these implications. A {\em branch}
$B$ consists of a number of nodes. A {\em node} $\gamma$ is a combination of a
{\em formula} $\psi$ and a {\em label} $\sigma$. A label is systematically
chosen name for a world in the Kripke model that is being constructed. Branches
are created and expanded by the application of {\em rules} to existing nodes on
a branch. 

A {\em rule} $R$ consists of
\begin{itemize}
\item A precondition $\mathrm{pre}(R)$, written above a horizontal bar, which
is a node containing variables;
\item A postcondition $\mathrm{post}(R)$, written below the horizontal bar,
which is a list of nodes containing variables. There are two types of
postconditions:
\begin{itemize}
\item Linear: add nodes to the current branch, written top-to-bottom;
\item Branching: create a number of new branches, written left-to-right, separated by a vertical bar.
\end{itemize}
\item Zero or more constraints, which restrict the values variables may take.
\end{itemize}
The rules employed by \oops\ are given in Table~\ref{tab:rules}. A rule $R$ is
applicable to a branch $B$, if there is a node $\gamma \in B$ that matches
$\mathrm{pre}(R)$, such that no constraints are violated and $R$ has not
previously been applied to $\gamma$.

A branch $B$ is {\em closed} if there is a label $\sigma$ and a formula
$\psi$, such that both $(\sigma, \psi) \in B$ and $(\sigma, \neg \psi)
\in B$. A branch $B$ is {\em open} if it is not closed and no more rules can be
applied to it. Thus, an open branch corresponds to a successful attempt to
satisfy $\varphi$, whereas a closed branch corresponds to a failed attempt to
satisfy $\varphi$. 
Specifically, for an open branch $B$, the labels determine the set of worlds
and the accessibility relations in the corresponding Kripke model. For each
label, the set of formulas given for that label determines the valuation in the
corresponding world in the Kripke model.
A tableau for $\varphi$ is closed if all branches are
closed, otherwise it is open. The appropriateness of a tableau system is
determined by the following properties:
\begin{description}
\item[Soundness] If the tableau for $\varphi$ is open, $\varphi$ is satisfiable.
\item[Completeness] If the tableau for $\varphi$ is closed, $\varphi$ is not
satisfiable.
\end{description}


\input{rules.tex}

The proof system used by \oops\ has been shown to be both sound and complete
\citep{valkenhoef2008}.  Furthermore, in the same work, the implementation was
shown to correspond to the formal description of the proof method.
Unfortunately, this work also shows that the algorithm used by \oops\ is in
{\sc EXPTIME}, whereas satisfiability for $S5_n$ is known to be {\sc PSPACE}
complete \citep{halpern1992}.
However, we believe that for educational purposes the functionality  offered
by \oops\ (see Section~\ref{sec:features}) easily makes up for this
shortcoming. Moreover, the implementation of these features does not depend on
the specific proof rules used. Thus, as future work, the current algorithm may
be replaced by one that is in {\sc PSPACE}.

\subsection{Implementation}

\subsection{Input language}
